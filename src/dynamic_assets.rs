//! Implementation of asset serving based on dynamic files generated by Webpack at runtime. Used in
//! debug mode.

use anyhow::Context as _;
use axum::{http::Request, response::IntoResponse, routing::get_service, Router};
use tokio::{
    fs,
    process::{Child, Command},
};
use tower_http::services::ServeDir;

use crate::utils::{EndpointError, EndpointResult};

pub(crate) struct AssetManager(Child);

impl AssetManager {
    pub(crate) fn new() -> anyhow::Result<Self> {
        let child = Command::new("npm")
            .arg("run")
            .arg("watch")
            .current_dir("html")
            .kill_on_drop(true)
            .spawn()
            .context("failed to spawn webpack")?;

        log::info!("spawned webpack");

        Ok(Self(child))
    }

    pub(crate) async fn stop(mut self) {
        let _ = self.0.kill().await;
    }
}

pub(crate) struct MutableAsset(pub(crate) &'static str);

impl MutableAsset {
    pub(crate) async fn call<B>(self, _req: Request<B>) -> EndpointResult {
        Ok(fs::read_to_string(self.0)
            .await
            .with_context(|| format!("failed to read mutable asset {}", self.0))?
            .into_response())
    }
}

macro_rules! mutable_asset {
    ($file:literal) => {
        $crate::assets::MutableAsset(concat!("html/dist/", $file))
    };
}
pub(crate) use mutable_asset;

pub(crate) fn immutable_assets() -> Router {
    Router::new().route(
        "/*_",
        get_service(ServeDir::new("html/dist/assets")).handle_error(|e| async {
            EndpointError::from(anyhow::Error::new(e).context("failed to serve immutable asset"))
        }),
    )
}
